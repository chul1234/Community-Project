# =======================================================
# DB 사용자 관리 (USERS) 테이블 관련 SQL
# =======================================================

# users 테이블 관련 기본 쿼리
# ? (물음표): Java의 PreparedStatement가 값으로 채울 파라미터 자리
user.insert=INSERT INTO users (user_id, name, phone, email, password) VALUES (?, ?, ?, ?, ?)
user.update=UPDATE users SET name = ?, phone = ?, email = ? WHERE user_id = ?
user.delete.by_user_id=DELETE FROM users WHERE user_id = ?

# [최종 수정] 로그인 및 헤더 정보용 쿼리: role_ids와 role_names를 모두 가져옵니다.
# SELECT u.* : users 테이블(u)의 모든 컬럼(user_id, name 등)을 선택
# LEFT JOIN: users 테이블(u)을 기준으로, users_roles(ur)와 roles(r) 테이블을 연결
#            (만약 사용자가 역할이 없더라도, users 정보는 조회되도록 LEFT JOIN 사용)
# GROUP_CONCAT(r.role_id SEPARATOR ', '):
#            여러 행(row)으로 나뉘어 있는 역할 ID(r.role_id)를 쉼표(,)로 구분하여 하나의 문자열로 합침
#            (예: 'ADMIN', 'USER' -> "ADMIN, USER")
# as role_ids: 합쳐진 문자열 컬럼의 별명을 'role_ids'로 지정
# WHERE u.user_id = ?: 특정 사용자 ID(?)로 조회
# GROUP BY u.user_id: GROUP_CONCAT 같은 집계 함수를 사용하기 위해 user_id 기준으로 그룹화
user.select.by_user_id=SELECT u.*, GROUP_CONCAT(r.role_id SEPARATOR ', ') as role_ids, GROUP_CONCAT(r.role_name SEPARATOR ', ') as role_names FROM users u LEFT JOIN users_roles ur ON u.user_id = ur.user_id LEFT JOIN roles r ON ur.role_id = r.role_id WHERE u.user_id = ? GROUP BY u.user_id

# [최종 수정] 사용자 목록 조회용 쿼리: 역할 ID(role_ids)와 역할 이름(role_names)을 모두 가져옵니다.
# (위 user.select.by_user_id 쿼리에서 WHERE 절만 빠진, 전체 사용자 목록 조회용 쿼리)
user.select.all=SELECT u.*, GROUP_CONCAT(r.role_id SEPARATOR ', ') as role_ids, GROUP_CONCAT(r.role_name SEPARATOR ', ') as role_names FROM users u LEFT JOIN users_roles ur ON u.user_id = ur.user_id LEFT JOIN roles r ON ur.role_id = r.role_id GROUP BY u.user_id

# users_roles 관련 쿼리
user_roles.delete.by_user_id=DELETE FROM users_roles WHERE user_id = ?
user_roles.insert=INSERT INTO users_roles (user_id, role_id) VALUES (?, ?)

# =======================================================
# 게시물(POSTS) 테이블 관련 SQL
# =======================================================

# [수정] ORDER BY 절 변경 (고정 글 우선 정렬) 및 pinned_order 포함
# CASE WHEN p.pinned_order IS NULL THEN 1 ELSE 0 END ASC: pinned_order가 NULL(일반글)이면 1, 아니면(고정글) 0 반환 후 오름차순 정렬 (0이 먼저)
# p.pinned_order ASC: 고정 글 내에서는 pinned_order 숫자 오름차순 정렬 (낮은 숫자 우선)
# p.post_id DESC: 그 외 일반 글은 최신순 정렬
post.select.all=SELECT p.post_id, p.title, p.user_id, u.name as author_name, p.created_at, p.view_count, p.pinned_order FROM posts p LEFT JOIN users u ON p.user_id = u.user_id ORDER BY CASE WHEN p.pinned_order IS NULL THEN 1 ELSE 0 END ASC, p.pinned_order ASC, p.post_id DESC LIMIT ? OFFSET ?

# [신규 추가] 전체 게시글 수 조회 (페이지네이션용)
post.count.all=SELECT COUNT(*) FROM posts

# 게시글 생성을 위한 INSERT 쿼리
post.insert=INSERT INTO posts (title, content, user_id) VALUES (?, ?, ?)

# [수정] p.pinned_order 추가
post.select.by_id=SELECT p.post_id, p.title, p.content, p.user_id, u.name as author_name, p.created_at, p.view_count, p.pinned_order FROM posts p LEFT JOIN users u ON p.user_id = u.user_id WHERE p.post_id = ?

# 특정 ID의 게시글 수정
post.update=UPDATE posts SET title = ?, content = ? WHERE post_id = ?

# 특정 ID의 게시글 삭제
post.delete.by_id=DELETE FROM posts WHERE post_id = ?

# 조회수 1 증가
post.increment.view_count=UPDATE posts SET view_count = view_count + 1 WHERE post_id = ?

# [신규 추가] 게시글 고정 상태/순서 업데이트
# pinned_order 값을 특정 숫자(고정) 또는 NULL(해제)로 변경
post.update.pinned_order=UPDATE posts SET pinned_order = ? WHERE post_id = ?

# [신규 추가] 현재 고정된 게시글 수 조회 (3개 제한용)
post.count.pinned=SELECT COUNT(*) FROM posts WHERE pinned_order IS NOT NULL

# =======================================================
# 댓글(comments) 테이블 관련 SQL
# =======================================================

# [수정] JOIN -> LEFT JOIN (작성자가 탈퇴해도 댓글이 보이도록)
# comments(c) 테이블을 기준으로, users(u) 테이블과 LEFT JOIN
# WHERE c.post_id = ?: 특정 게시글(post_id)에 달린 댓글만 필터링
# ORDER BY c.comment_id ASC: comment_id를 기준으로 오름차순 정렬 (작성순, 오래된 댓글이 위로)
comment.select.by_post_id=SELECT c.comment_id, c.post_id, c.content, c.user_id, u.name as author_name, c.created_at FROM comments c LEFT JOIN users u ON c.user_id = u.user_id WHERE c.post_id = ? ORDER BY c.comment_id ASC

# 특정 ID의 댓글 하나만 조회
comment.select.by_id=SELECT * FROM comments WHERE comment_id = ?

# 댓글 생성을 위한 INSERT 쿼리
comment.insert=INSERT INTO comments (post_id, content, user_id) VALUES (?, ?, ?)

# 댓글 수정을 위한 UPDATE 쿼리
comment.update=UPDATE comments SET content = ? WHERE comment_id = ?

# 댓글 삭제를 위한 DELETE 쿼리
comment.delete.by_id=DELETE FROM comments WHERE comment_id = ?

# =======================================================
# 메뉴(MENUS) 테이블 관련 SQL
# =======================================================

# 메뉴 전체 목록 조회 (depth 오름차순, priority 오름차순 정렬)
# ORDER BY depth ASC, priority ASC:
#            1차로 depth(깊이) 오름차순(ASC) 정렬 (대메뉴(1)가 소메뉴(2)보다 먼저)
#            2차로 priority(우선순위) 오름차순(ASC) 정렬 (같은 depth 내에서 숫자가 낮은 메뉴가 먼저)
menu.select.all_sorted=SELECT * FROM menus ORDER BY depth ASC, priority ASC