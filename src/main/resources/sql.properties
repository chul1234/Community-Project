# =======================================================
# DB 사용자 관리 (USERS) 테이블 관련 SQL
# =======================================================

# users 테이블 관련 기본 쿼리
# ? (물음표): Java의 PreparedStatement가 값으로 채울 파라미터 자리
user.insert=INSERT INTO users (user_id, name, phone, email, password) VALUES (?, ?, ?, ?, ?)
user.update=UPDATE users SET name = ?, phone = ?, email = ? WHERE user_id = ?
user.delete.by_user_id=DELETE FROM users WHERE user_id = ?

# [최종 수정] 로그인 및 헤더 정보용 쿼리: role_ids와 role_names를 모두 가져옵니다.
# SELECT u.* : users 테이블(u)의 모든 컬럼(user_id, name 등)을 선택
# LEFT JOIN: users 테이블(u)을 기준으로, users_roles(ur)와 roles(r) 테이블을 연결
#            (만약 사용자가 역할이 없더라도, users 정보는 조회되도록 LEFT JOIN 사용)
# GROUP_CONCAT(r.role_id SEPARATOR ', '):
#            여러 행(row)으로 나뉘어 있는 역할 ID(r.role_id)를 쉼표(,)로 구분하여 하나의 문자열로 합침
#            (예: 'ADMIN', 'USER' -> "ADMIN, USER")
# as role_ids: 합쳐진 문자열 컬럼의 별명을 'role_ids'로 지정
# WHERE u.user_id = ?: 특정 사용자 ID(?)로 조회
# GROUP BY u.user_id: GROUP_CONCAT 같은 집계 함수를 사용하기 위해 user_id 기준으로 그룹화
user.select.by_user_id=SELECT u.*, GROUP_CONCAT(r.role_id SEPARATOR ', ') as role_ids, GROUP_CONCAT(r.role_name SEPARATOR ', ') as role_names FROM users u LEFT JOIN users_roles ur ON u.user_id = ur.user_id LEFT JOIN roles r ON ur.role_id = r.role_id WHERE u.user_id = ? GROUP BY u.user_id 

# [최종 수정] 사용자 목록 조회용 쿼리: 역할 ID(role_ids)와 역할 이름(role_names)을 모두 가져옵니다.
# (위 user.select.by_user_id 쿼리에서 WHERE 절만 빠진, 전체 사용자 목록 조회용 쿼리)
user.select.all=SELECT u.*, GROUP_CONCAT(r.role_id SEPARATOR ', ') as role_ids, GROUP_CONCAT(r.role_name SEPARATOR ', ') as role_names FROM users u LEFT JOIN users_roles ur ON u.user_id = ur.user_id LEFT JOIN roles r ON ur.role_id = r.role_id GROUP BY u.user_id LIMIT ? OFFSET ?

# 전체 사용자 수 조회 (페이지네이션용) 
user.count.all=SELECT COUNT(*) FROM users

# users_roles 관련 쿼리
user_roles.delete.by_user_id=DELETE FROM users_roles WHERE user_id = ?
user_roles.insert=INSERT INTO users_roles (user_id, role_id) VALUES (?, ?)

# =======================================================
# 게시물(POSTS) 테이블 관련 SQL
# =======================================================

# [수정] ORDER BY 절 변경 (고정 글 우선 정렬) 및 pinned_order 포함
# CASE WHEN p.pinned_order IS NULL THEN 1 ELSE 0 END ASC: pinned_order가 NULL(일반글)이면 1, 아니면(고정글) 0 반환 후 오름차순 정렬 (0이 먼저)
# p.pinned_order ASC: 고정 글 내에서는 pinned_order 숫자 오름차순 정렬 (낮은 숫자 우선)
# p.post_id DESC: 그 외 일반 글은 최순 정렬
post.select.all=SELECT p.post_id, p.title, p.user_id, u.name as author_name, p.created_at, p.view_count, p.pinned_order FROM posts p LEFT JOIN users u ON p.user_id = u.user_id ORDER BY CASE WHEN p.pinned_order IS NULL THEN 1 ELSE 0 END ASC, p.pinned_order ASC, p.post_id DESC LIMIT ? OFFSET ?

# [ 추가] 전체 게시글 수 조회 (페이지네이션용)
post.count.all=SELECT COUNT(*) FROM posts

# [추가] 에디터 이미지 파일명을 포함하는 게시글 수 카운트 (삭제/수정 시 사용)
post.count.by_editor_image=SELECT COUNT(*) FROM posts WHERE content LIKE ?


# 게시글 생성을 위한 INSERT 쿼리
post.insert=INSERT INTO posts (title, content, user_id) VALUES (?, ?, ?)

# [수정] p.pinned_order 추가
post.select.by_id=SELECT p.post_id, p.title, p.content, p.user_id, u.name as author_name, p.created_at, p.view_count, p.pinned_order FROM posts p LEFT JOIN users u ON p.user_id = u.user_id WHERE p.post_id = ?

# 특정 ID의 게시글 수정
post.update=UPDATE posts SET title = ?, content = ? WHERE post_id = ?

# 특정 ID의 게시글 삭제
post.delete.by_id=DELETE FROM posts WHERE post_id = ?

# 조회수 1 증가
post.increment.view_count=UPDATE posts SET view_count = view_count + 1 WHERE post_id = ?

# [ 추가] 게시글 고정 상태/순서 업데이트
# pinned_order 값을 특정 숫자(고정) 또는 NULL(해제)로 변경
post.update.pinned_order=UPDATE posts SET pinned_order = ? WHERE post_id = ?

# [ 추가] 현재 고정된 게시글 수 조회 (3개 제한용)
post.count.pinned=SELECT COUNT(*) FROM posts WHERE pinned_order IS NOT NULL

# =======================================================
# 댓글(comments) 테이블 관련 SQL
# =======================================================

# [수정] JOIN -> LEFT JOIN (작성자가 탈퇴해도 댓글이 보이도록)
# comments(c) 테이블을 기준으로, users(u) 테이블과 LEFT JOIN
# WHERE c.post_id = ?: 특정 게시글(post_id)에 달린 댓글만 필터링
# ORDER BY c.comment_id ASC: comment_id를 기준으로 오름차순 정렬 (작성순, 오래된 댓글이 위로)
# [대댓글 수정] SELECT 리스트에 c.parent_comment_id 추가
comment.select.by_post_id=SELECT c.comment_id, c.post_id, c.content, c.user_id, u.name as author_name, c.created_at, c.parent_comment_id FROM comments c LEFT JOIN users u ON c.user_id = u.user_id WHERE c.post_id = ? ORDER BY c.comment_id ASC

# 특정 ID의 댓글 하나만 조회
# [대댓글 수정] SELECT * 이므로 parent_comment_id가 자동으로 포함되어 수정할 필요 없음.
comment.select.by_id=SELECT * FROM comments WHERE comment_id = ?

# 댓글 생성을 위한 INSERT 쿼리
# [대댓글 수정] INSERT 컬럼에 parent_comment_id 추가, VALUES에 ? 추가
comment.insert=INSERT INTO comments (post_id, content, user_id, parent_comment_id) VALUES (?, ?, ?, ?)

# 댓글 수정을 위한 UPDATE 쿼리
comment.update=UPDATE comments SET content = ? WHERE comment_id = ?

# 댓글 삭제를 위한 DELETE 쿼리
comment.delete.by_id=DELETE FROM comments WHERE comment_id = ?

# =======================================================
# 메뉴(MENUS) 테이블 관련 SQL
# =======================================================

# 메뉴 전체 목록 조회 (depth 오름차순, priority 오름차순 정렬)
# ORDER BY depth ASC, priority ASC:
#            1차로 depth(깊이) 오름차순(ASC) 정렬 (대메뉴(1)가 소메뉴(2)보다 먼저)
#            2차로 priority(우선순위) 오름차순(ASC) 정렬 (같은 depth 내에서 숫자가 낮은 메뉴가 먼저)
menu.select.all_sorted=SELECT * FROM menus ORDER BY depth ASC, priority ASC

# =======================================================
# 파일(post_files) 테이블 관련 SQL
# =======================================================

# 파일 메타데이터 INSERT
file.insert=INSERT INTO post_files (post_id, original_name, saved_name, content_type, file_size, file_path) VALUES (?, ?, ?, ?, ?, ?)

# 특정 게시글의 파일 목록 조회
file.select.by_post_id=SELECT file_id, post_id, original_name, saved_name, content_type, file_size, file_path FROM post_files WHERE post_id = ?

# 특정 파일 한 개 조회
file.select.by_id=SELECT file_id, post_id, original_name, saved_name, content_type, file_size, file_path FROM post_files WHERE file_id = ?

# 특정 파일 한 개 삭제
file.delete.by_id=DELETE FROM post_files WHERE file_id = ?

# 특정 게시글에 연결된 모든 파일 삭제
file.delete.by_post_id=DELETE FROM post_files WHERE post_id = ?

# =======================================================
# 대용량 게시물(big_posts) 테이블 관련 SQL (최종 + 조회수)
# =======================================================

# 키셋 페이징 첫 페이지 조회: 최신 게시글부터 LIMIT 개수만큼 조회 (목록 + 조회수 표시용)
bigpost.select.first=SELECT post_id,title,user_id,created_at,view_count FROM big_posts ORDER BY post_id DESC LIMIT ?

# 키셋 페이징 다음 페이지 조회: 마지막 post_id보다 작은 게시글 이어서 조회
bigpost.select.next=SELECT post_id,title,user_id,created_at,view_count FROM big_posts WHERE post_id<? ORDER BY post_id DESC LIMIT ?

# 단건 상세 조회: content 포함, 상세 화면에서 사용
bigpost.select.one=SELECT * FROM big_posts WHERE post_id=?

# 전체 게시글 수 조회: COUNT(*) 금지, 카운터 테이블 사용
bigpost.count.all=SELECT total_count FROM big_posts_counter WHERE id=1

# 게시글 등록
bigpost.insert=INSERT INTO big_posts(title,content,user_id) VALUES(?,?,?)

# 게시글 수정: 제목/내용만 수정 (조회수 영향 없음)
bigpost.update=UPDATE big_posts SET title=?,content=? WHERE post_id=?

# 게시글 삭제
bigpost.delete=DELETE FROM big_posts WHERE post_id=?

# 게시글 등록 시 전체 개수 +1 (카운터 테이블)
bigpost.counter.increment=UPDATE big_posts_counter SET total_count=total_count+1 WHERE id=1

# 게시글 삭제 시 전체 개수 -1 (카운터 테이블)
bigpost.counter.decrement=UPDATE big_posts_counter SET total_count=total_count-1 WHERE id=1

# 상세 페이지 진입 시 조회수 +1 처리
bigpost.view.increment=UPDATE big_posts SET view_count=view_count+1 WHERE post_id=?

# OFFSET 기반 페이징 조회: 검색 모드에서 사용 (기존 구조 유지)
bigpost.select.page=SELECT post_id,title,user_id,created_at,view_count FROM big_posts ORDER BY post_id DESC LIMIT ?,?

# =======================================================
# 대용량 게시판 통계 (big_posts)
# =======================================================

# 사용자별 게시글 수 Top10
bigstats.topUsers=SELECT user_id, COUNT(*) AS cnt FROM big_posts GROUP BY user_id ORDER BY cnt DESC LIMIT 10

# 조회수 Top10
bigstats.topViews=SELECT post_id, title, view_count FROM big_posts ORDER BY view_count DESC LIMIT 10

# 전 기간 일별 게시글 수 (전체 데이터)
bigstats.daily=SELECT DATE(created_at) AS day, COUNT(*) AS cnt FROM big_posts GROUP BY DATE(created_at) ORDER BY day ASC

# =======================================================
# segment_weight (버스/트램 구간 가중치) 테이블 관련 SQL
# =======================================================

# BUS 모드 구간 전체 조회 (최단경로 계산용)
segment_weight.select.all_bus=SELECT mode, route_id, from_id, to_id, from_lat, from_lng, to_lat, to_lng, distance_m, travel_sec_avg, sample_count FROM segment_weight WHERE mode = 'BUS'


